===================================
CO2 reduction at polycrystalline Au
===================================

This tutorial explains how a typical coupled mass transport - microkinetics simulation can be initialized and run. It is based on the publication Ringe *et al.*, submitted to *Nat. Catal.*, **2019**.

Creation of the ``CatINT`` input file
-------------------------------------

Import
~~~~~~

We start with the creation of the ``CatINT`` python input file and import the main transport class and the calculator:

.. code:: python

    from catint.transport import Transport
    from catint.calculator import Calculator

System Settings
~~~~~~~~~~~~~~~

First, we define the system reaction conditions:

.. code:: python

    pH = 6.8
    system=\
        {
        #ENVIRONMENTAL CONDITIONS
        'temperature':  298,         #K
        'pressure':     1.013,       #bar
        'bulk_pH': pH,
        #MASS TRANSPORT
        'boundary thickness': 8.E-05 #m
        #ELECTROSTATICS
        'epsilon': 78.36,            #eps_0
        'migration': True,
        #REACTIONS
        'electrode reactions': True,
        'electrolyte reactions': True,
        #CHARGING
        'charging_scheme':'comsol'
        'phiPZC': 0.16,              #V vs. SHE
        'Stern capacitance': 20.,    #micro F/cm2
        #KINETICS
        'potential drop':'Stern',
        'active_site_density': 9.61-05/unit_NA*(1e10)**2, #mol sites/m^2
        #INITIALIZATION
       # 'init_folder':init_folder,
        }

``temperature`` and ``pressure`` are important for the finite temperature free energy corrections that are applied in ``CatMAP``, but the temperature also enters the mass transport equations. The ``pH`` should be adjusted to the reaction conditions. `boundary thickness`` refers to the boundary thickness which defines the cell dimensions. ``epsilon`` is the bulk dielectric constant that enters the mass transport equations. ``migration`` turns the migrational motion of species on or off. Further, electrode and electrolyte reactions can be turned on or off. The charging of the surface is controlled via the ``charging_scheme`` tag. Currently, ``CatINT`` supports different methods to define a surface charge density - potential relation :math:`\sigma(\phi^\mathrm{M})` which is used to evaluate potential-dependent free energies:

- ``'comsol'``:  Get the relation from ``COMSOL`` directly via the electrostatics defined there.
- ``'input'``:     Define a relation manually. This enables to take the charging relation directly from the ``CatMAP`` input file. There, currently different ways are supported:
    - ``sigma_input=['CH',20.]``. Define surface charge density via :math: `\sigma=C_H (\phi^\mathrm{M}-\phi^\mathrm{PZC})`, where math: `C_H` is a capacitance.
    - ``sigma_input='file.txt'``: Define surface charge density from  :math:`\sigma(\phi^\mathrm{M})` relation given in file name. The discrete data in the file is interpolated

For the electrostatics within the mass transport (PNP equations), the `Stern capacitance` (also called gap capacitance) is needed to define the Robin boundary condition. The same is valid for the PZC which is given on an SHE scale. The `potential drop` defines how to calculate the driving electrochemical potential in ``CatMAP``, i.e. if a Frumkin correction is considered or not. If ``'potential_drop':'Stern'`` is selected a Frumkin correction is applied, so that the driving potential drop is :math: `\phi^\mathrm{M}-\phi^\ddagger` with :math: `\phi^\ddagger` is the potential at the reaction plane.

Finally ``CatINT`` supports to initialize a run form a previous one by using the ``init_folder`` tag. 

Electrolyte Reactions
~~~~~~~~~~~~~~~~~~~~~

We define electrolyte reactions which should be included in the mass transport. Currently ``CatINT`` supports multiple buffer reactions which are defined in the ``catint/data.py`` file. Here we include bicarbonate buffer reactions both using water and protons as donors (acidic and alkaline conditions) as well as the water self dissociation equilibria

.. code:: python

    electrolyte_reactions=['bicarbonate-base','water-diss',{'additional_cell_reactions':'bicarbonate-acid'}]

``CatINT`` evaluates concentrations at the boundary layer based on these buffer equilibria reactions. Since the acidic buffer reactions are already contained in the combination of alkaline and water dissociation, they are included as ``additional_cell_reactions``, meaning that they are active during the mass transport simulation, but not used for initializing the concentrations. 

Electrode Reactions
~~~~~~~~~~~~~~~~~~~

Now it is time to think about the reactions at the electrode, the electrochemical reactions. In our case, we consider the reduction of CO2 with water as a proton donor, which is defined as:

.. code:: python

    electrode_reactions={
        'CO': {'reaction': 'CO2 + H2O + 2 e- -> CO + 2 OH-'},
    }

Species Definitions
~~~~~~~~~~~~~~~~~~~

After defining the reactions, we need to also think about all species that our system, we define them as a dictionary:

.. code:: python

    species=\
        {
        'K+':               {'bulk_concentration':   'charge_neutrality',
                             'MPB_radius':           2*3.5e-10},},
        'CO2':              {'bulk_concentration':   'Henry'},
        'OH-':              {'bulk_concentration':   10**(pH-14.)*1000.0}, #mol/m^3
        'CO':               {'bulk_concentration':   0.0}
        }
    
All species that are part of the electrolyte reactions are already automatically added to the species dictionary in ``CatINT``. All other species have to be added here. Charges are automatically assigned according to the species name. We add potassium cations which should neutralize all anions so that the system is charge neutral in the bulk solution (boundary layer). We chose a ``MPB_radius`` of 3.5 Angstrom which is important since the negative electrode potental dramatically increases the potassium concentrations. We then define the CO2 concentration at the boundary layer to be given by Henry's law which will use the pressure defined in system settings and the Henry constant in ``data/henry_constants.txt`` to evaluate the equilibrium CO2 concentration. The buffer component concentrations are now evaluated using the equilibrium buffer equations and must not be specified. It is also possible though to specify a buffer concentration and let ``CatINT`` calculate the CO2 concentration via the buffer equations. Finally, we set the concentration of hydroxide anions according to the pH (proton concentration are automatically evaluated using the water dissociation equilibrium). All concentrations are given in :math: `\mathrm{mol}/\mathrm{m}^3`.

Descriptors
~~~~~~~~~~~

In a common application, ``CatINT`` calculations should be run for a specified parameter range. In this example, we want to simulate a polarization curve, our parameter or descriptor is therefore the electrode potential, we define it like this:

.. code:: python

    phimin=-0.5
    phimax=-2.0
    descriptors={'phiM':list(np.linspace(phimin,phimax,-(phimax-phimin)/dphi+1))}

Currently ``CatINT`` supports only the potential as descriptor, others could be implemented, if needed. The ``CatINT`` calculator iterates over the descriptor list and solves the coupled mass transport -- microkinetics model at each potential.

COMSOL arguments
~~~~~~~~~~~~~~~~~~~~~~~~~~~

There are a couple of predefined ``COMSOL`` arguments which are saved in the ``transport.comsol_args`` dictionary. One important one is

.. code:: python
    comsol_args['desc_method']

``desc_method`` defines if/how to treat descriptors as parameter sweeps in ``COMSOL``:
- ``internal``: descriptor given here will be used for iterating internally in comsol. If this selected descriptor is not the potential this could lead to convergence problems!
- ``internal-reinit``: at each parameter set, the solutions are reinitialized (default)
- ``internal-cont``: the solution of the previous parameter set is used to initialize the next
- ``external``: parameters are updated within this comsol.py routine and comsol is recompiled and relaunched for each new parameter set.

.. code:: python

    comsol_args['par_name']
    comsol_args['par_values']
    comsol_args['par_method']

``par_name`` selects a parameter from self.descriptors to use as parameter sweep, ``par_values`` lists the value of this parameter.

We can define COMSOL variables and parse them to CatINT via the ``comsol_args`` tag:

.. code:: python

    comsol_args={}
    #parameter
    comsol_args['parameter']={}   
    comsol_args['parameter']['grid_factor_domain']=[str(100),'Grid factor']
    comsol_args['parameter']['grid_factor_bound']=[str(200),'Grid factor']
    #solver_settings
    comsol_args['solver_settings']={}
    comsol_args['solver_settings']['direct']={}
    comsol_args['solver_settings']['direct']['nliniterrefine']=True
    comsol_args['solver_settings']['ramp']={}
    comsol_args['solver_settings']['ramp']['names']=['PZC','CS']
    comsol_args['solver_settings']['ramp']['dramp']=0.01
    #par_method
    comsol_args['par_method']='internal'

    #SOLVER SEQUENCE
    #comsol_args['solver_settings']['solver_sequence']='tds_elstat'
    #OTHER PARAMETER
    #comsol_args['parameter']['RF']=[1,'Roughness Factor']

This is in particular useful for modifying numerical solver settings. In our case, we first define a ``grid_factor`` which tells comsol about the minimal finite element mesh width. A higher factor means a finer mesh and the mesh can be defined for the domain and boundary separately. Parameter definitions always a list of two entries, the value parsed as a string and the name or description inside COMSOL. Some more specific numerical parameters can be edited and changed here to help convergence. In particular, the ``'ramp'`` flag enables to slowly ramp non-linearitis in the equations, in our case it slowly ramps up te PZC an the Helmholtz/Stern/gap capacitance which can be useful if the systems has a PZC far from the initial potential to be evaluated. A flux ramping is always applied and controlled by the `'dramp'` flag which defines the interval in which the fluxes are ramped from 0 to 100 %.  Additional possible settings involve the definition of solver sequences to improve convergence (e.g. first solving electrostatics only, then the coupled mass transport/electrostatic problem). Also, it is possible to define a roughness factor which multiplies all fluxes by a constant.

``par_method`` is an additional flag which defines how the parameter space is sampled. In case ``internal`` is selected, COMSOL uses internal looping over the parameter space which is given by the flux ramping. If ``external`` is selected instead, ``COMSOL`` calculations are performed for the descriptor list defined above.

``CatMAP`` arguments
~~~~~~~~~~~~~~~~

Some additional arguments can be parsed to the ``CatMAP`` calculator:

.. code:: python

    catmap_args={}
    #CATMAP DESCRIPTOR RAMPING
    catmap_args['desc_method']='automatic'
    #catmap_args['min_desc']=0.0
    catmap_args['min_desc_delta']=0.2
    catmap_args['max_desc_delta']=0.2
    #INTERACTIONS
    catmap_args['n_inter']='automatic'

In a regular ``CatMAP``-``COMSOL`` iteration loop, a single ``CatMAP`` calculation is required at the descriptor value of choice. This is referred to as ``desc_method='single_point'``. Sometimes, however, some potential values are hard to converge and it is better to provide ``CatMAP`` with a range of potentials. ``CatMAP`` will then try to find stable starting points and solve for all potentials and ``CatINT`` selects the potential that was actually needed. This happens if we choose ``desc_method='automatic'``. For this case, ``min_desc`` specifies the minimum descriptor value in the new created list of descriptors. Alternatively, ``min/max_desc_delta`` can be used to create a new list of descriptors around the current descriptor value. The descriptor range can be also taken from the ``CatMAP`` input file (``desc_method='from_input'``).

Flux definition
~~~~~~~~~~~~~~~

Now it is time to define how fluxes are evaluated within the ``CatINT`` model. In our case, we will use ``CatMAP`` to define fluxes but multiple options are available (cf. :ref:`flux-definition`).

.. code:: python

    species['CO']['flux']='catmap' #CO production rate
    species['CO2']['flux']='catmap' #CO2 consumption rate
